<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  background: #fcfcfa;
}

.stroke {
  fill: none;
  stroke: #000;
  stroke-width: 3px;
}

.fill {
  fill: #fff;
}

.graticule {
  fill: none;
  stroke: #777;
  stroke-width: .5px;
  stroke-opacity: .5;
}

.land {
  fill: #222;
}

.boundary {
  fill: none;
  stroke: #fff;
  stroke-width: .5px;

}


</style>
<head>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
<script src="https://d3js.org/topojson.v1.min.js"></script>
<script src="http://d3js.org/queue.v1.min.js"></script>
</head>
<body>

<div id  = "wrapper">
  <button id = "play"> Play </button>
  <span id = "year"> Year </span>
</div>

<script>

var width = 960,
    height = 580;


//var color = d3.scale.category10();

var minimumTemp = -2.4
var maximumTemp = 3.6

//creates a color scheme. This needs work, as carbon emissions can't be split properly. Might have to normalize the data. 

/*var colors = d3.scaleLinear()
    .domain(d3.ticks(minimumTemp, maximumTemp, 10))
    .range(['#006837', '#1a9850', '#66bd63', '#a6d96a', '#d9ef8b', '#fee08b', '#fdae61', '#f46d43', '#d73027', '#a50026']); */

var colors = d3.scaleLinear()
    .domain(d3.ticks(minimumTemp, maximumTemp, 10))
    .range(['#006837', '#1a9850', '#66bd63', '#a6d96a', '#d9ef8b', '#fee08b', '#fdae61', '#f46d43', '#d73027', '#a50026']);

var projection = d3.geoKavrayskiy7()
    .scale(170)
    .translate([width / 2, height / 2])
    .precision(.1);

var path = d3.geoPath()
    .projection(projection);

var graticule = d3.geoGraticule();

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

svg.append("defs").append("path")
    .datum({type: "Sphere"})
    .attr("id", "sphere")
    .attr("d", path);

svg.append("use")
    .attr("class", "stroke")
    .attr("xlink:href", "#sphere");

svg.append("use")
    .attr("class", "fill")
    .attr("xlink:href", "#sphere");


//add data to the queue or make different queues based on what the user selects.

queue()
  .defer(d3.json, "Data/world110m.json")
  .defer(d3.json, "Data/tempAnomaly.json")
  .await(temperatureMap);


function temperatureMap(error, world, temperature){
  var countries = topojson.feature(world, world.objects.countries).features;

//create the world map

  //console.log(countries[0].id);
// was here before

  //console.log((temperature[0]['Country Code']));

//join carbon emissions data to the TopoJSON for each year. So this will be done in a loop from 1970-2013



var startYear = 1960;
var endYear = 2012;
var currentYear = startYear;  
var playing = false;
function update(){

    countries = topojson.feature(world, world.objects.countries).features;

    //console.log(countries[0].id);
    //console.log((temperature[0]['Country Code']));


    svg.selectAll(".country")
    .data(countries)
    .enter().insert("path", ".graticule")
    .attr("class", "country")
    .attr("d", path);
    //.style("fill", function(d, i) { return color(d.color = d3.max(neighbors[i], function(n) { return countries[n].color; }) + 1 | 0); });

    countries.forEach(function(country){
      var result = temperature.filter(function(temperature){
        return temperature['Country Code'] == country.id;
      });
      delete country.id;
      country.temperature = (result[0] != undefined) ? result[0][String(currentYear)] : null;

    });
    console.log(countries[0].temperature);

  //fill the map based on the color scheme.

    svg.insert("path", ".graticule")
        .datum(topojson.mesh(world, world.objects.countries, function(a, b) { return a !== b; }))
        .attr("class", "boundary")
        .attr("d", path);
    svg.selectAll(".country")
        .data(countries)
        .style("fill", function(d){return colors(d.temperature)});
  }
  
  update();

function animate(){
var timer;  // create timer object
  d3.select('#play')  
    .on('click', function() {  // when user clicks the play button
      if(playing == false) {  // if the map is currently playing
        timer = setInterval(function(){   // set a JS interval
          if(currentYear < endYear) {  
              currentYear +=1;  // increment the current attribute counter
          } else {
              currentYear = startYear;  // or reset it to zero
          }
          //svg.selectAll(".country").remove();
          update();  // update the representation of the map 
          d3.select('#year').html(currentYear);  // update the clock
        }, 500);
      
        d3.select(this).html('stop');  // change the button label to stop
        playing = true;   // change the status of the animation
      } else {    // else if is currently playing
        clearInterval(timer);   // stop the animation by clearing the interval
        d3.select(this).html('play');   // change the button label to play
        playing = false;   // change the status again
      }
  });
  }
  animate();

 

}
d3.select(self.frameElement).style("height", height + "px");

</script>